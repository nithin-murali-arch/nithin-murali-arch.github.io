<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-adsense-account" content="ca-pub-8268518333873371">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8268518333873371"
     crossorigin="anonymous"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-9LBRY92EL5"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-9LBRY92EL5");

      // Simple mobile detection
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);

      // Place this near the top of the script, after other let/const declarations
      let passengerInterval = null;
      let stationInterval = null;
      let weekInterval = null;

      // --- Pending trains to assign ---
      let pendingTrains = 0;

      // --- BEGIN: Bridges and Tunnels (commented out for future use) ---
      // In gameState:
      // bridgesAvailable: 2,
      // tunnelsAvailable: 2,
      // ...
      // In UI panel:
      /*
      <div class="stat">Bridges: <span id="bridges">2</span></div>
      <div class="stat">Tunnels: <span id="tunnels">2</span></div>
      */
      // In upgrades panel:
      /*
      <div class="upgrade-item">
          <span>+1 Bridge</span>
          <button class="upgrade-btn" onclick="buyUpgrade('bridge')">Buy</button>
      </div>
      <div class="upgrade-item">
          <span>+1 Tunnel</span>
          <button class="upgrade-btn" onclick="buyUpgrade('tunnel')">Buy</button>
      </div>
      */
      // In buyUpgrade:
      /*
      case 'bridge':
          gameState.bridgesAvailable++;
          upgradeSuccessful = true;
          break;
      case 'tunnel':
          gameState.tunnelsAvailable++;
          upgradeSuccessful = true;
          break;
      */
      // In updateUI:
      /*
      document.getElementById('bridges').textContent = gameState.bridgesAvailable;
      document.getElementById('tunnels').textContent = gameState.tunnelsAvailable;
      */
      // --- END: Bridges and Tunnels (commented out for future use) ---

      // --- Refactor: Upgrades as a data structure for maintainability ---
      const UPGRADE_DEFS = [
        { key: 'line', label: '+1 Line', handler: () => buyUpgrade('line') },
        { key: 'train', label: '+2 Trains', handler: () => buyUpgrade('train') },
        { key: 'interchange', label: '+1 Interchange', handler: () => buyUpgrade('interchange') },
        // { key: 'bridge', label: '+1 Bridge', handler: () => buyUpgrade('bridge') }, // future
        // { key: 'tunnel', label: '+1 Tunnel', handler: () => buyUpgrade('tunnel') }, // future
      ];

      function renderUpgradesPanel() {
        const upgradesDiv = document.getElementById('upgrades');
        if (!upgradesDiv) return;
        upgradesDiv.innerHTML = `
          <h3 style="margin-top: 0;">Weekly Upgrades</h3>
          <div class="upgrade-status">
            Upgrades used: <span id="upgradesUsed">${gameState.upgradesPurchased}</span>/<span id="maxUpgrades">${gameState.maxUpgradesPerWeek}</span>
          </div>
          ${UPGRADE_DEFS.map(upg => `
            <div class="upgrade-item">
              <span>${upg.label}</span>
              <button class="upgrade-btn" onclick="(${upg.handler.toString()})()">Buy</button>
            </div>
          `).join('')}
        `;
      }
    </script>
    <title>Mini Metro Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background: #34495e;
            cursor: crosshair;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(10,12,16,0.95) !important;
            padding: 18px 18px 14px 18px !important;
            border-radius: 14px !important;
            box-shadow: 0 4px 24px #0006 !important;
            font-size: 15px !important;
            min-width: 220px;
            max-width: 320px;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: #f8f8f8;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0;
        }

        .ui-stats {
            width: 100%;
            margin-bottom: 6px;
        }

        .stat {
            margin: 2px 0;
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 0.01em;
        }

        .stat-main {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
        }

        .ui-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, #222 0%, #444 100%);
            opacity: 0.5;
            margin: 10px 0 8px 0;
            border-radius: 1px;
        }

        #inventoryPanel {
            width: 100%;
            display: flex;
            gap: 8px;
            justify-content: flex-start;
            align-items: center;
        }

        #inventoryPanel .upgrade-btn {
            border-radius: 6px;
            margin-right: 0;
            border: none;
            font-size: 15px;
            font-weight: 500;
            padding: 8px 18px;
            transition: background 0.2s, color 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px #0002;
        }

        #inventoryPanel .upgrade-btn:last-child {
            border-radius: 6px;
            margin-right: 0;
            border: none;
        }

        #inventoryPanel .upgrade-btn:hover:not(:disabled) {
            background: #2ecc71 !important;
            color: #fff !important;
            box-shadow: 0 4px 12px #27ae6040;
        }

        #inventoryPanel .upgrade-btn:active {
            background: #229954 !important;
            color: #fff !important;
        }

        @media (max-width: 600px) {
            #ui {
                min-width: 140px;
                max-width: 98vw;
                padding: 10px 6px 8px 8px !important;
                font-size: 13px !important;
            }
            .stat-main { font-size: 15px; }
            #inventoryPanel .upgrade-btn { font-size: 13px; padding: 7px 10px; }
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .line-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 16px;
            touch-action: manipulation;
        }

        .line-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .line-btn.active {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background: #34495e;
            color: white;
            font-size: 20px;
            touch-action: manipulation;
        }

        .control-btn:hover {
            background: #4a5f7a;
        }

        #info {
            position: fixed !important;
            top: 10px !important;
            right: 230px !important;
            min-width: 120px !important;
            max-width: 300px !important;
            width: auto !important;
            z-index: 9999 !important;
            background: rgba(0,0,0,0.8) !important;
            padding: 10px !important;
            border-radius: 10px !important;
            backdrop-filter: blur(10px) !important;
            box-sizing: border-box !important;
            text-align: center !important;
            font-size: 12px !important;
            transition: width 0.2s, min-width 0.2s, max-width 0.2s, padding 0.2s !important;
        }

        #info.collapsed {
            width: 56px !important;
            min-width: 0 !important;
            max-width: 56px !important;
            height: auto !important;
            padding: 8px !important;
            margin: 0 !important;
            text-align: center !important;
            overflow: visible !important;
            box-sizing: border-box !important;
            display: block !important;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .upgrade-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .upgrade-btn:hover:not(:disabled) {
            background: #2ecc71;
        }

        .upgrade-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .upgrade-status {
            font-size: 11px;
            color: #bdc3c7;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 8px;
            }
            
            #info {
                font-size: 10px;
                padding: 8px;
                max-width: 120px;
            }
            
            #upgrades {
                min-width: 150px;
                padding: 10px;
            }
            
            .line-btn, .control-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(15px);
        }

        .restart-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: background 0.3s ease;
        }

        .restart-btn:hover {
            background: #c0392b;
        }

        #upgrades {
            position: fixed !important;
            top: 10px !important;
            right: 10px !important;
            min-width: 200px;
            max-width: 300px;
            width: auto;
            z-index: 9999 !important;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-sizing: border-box;
            text-align: left;
            transition: width 0.2s, min-width 0.2s, max-width 0.2s, padding 0.2s;
        }
        #upgrades.collapsed {
            width: 56px !important;
            min-width: 0 !important;
            max-width: 56px !important;
            height: auto !important;
            padding: 8px !important;
            margin: 0 !important;
            text-align: center !important;
            overflow: visible !important;
            box-sizing: border-box !important;
            display: block !important;
        }

        /* Add margin to collapse icons */
        #collapseUpgradesBtn, #collapseInfoBtn {
            margin-right: 8px !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="ui-stats">
            <div class="stat stat-main">Week: <span id="week">1</span></div>
            <div class="stat stat-main">Score: <span id="score">0</span></div>
            <div class="stat">Lines: <span id="lines">3</span></div>
            <div class="stat">Trains: <span id="trains">6</span></div>
        </div>
        <div class="ui-divider"></div>
        <div id="inventoryPanel"></div>
    </div>

    <div id="controls">
        <button class="control-btn" id="pauseBtn" onclick="togglePause()">⏸️</button>
        <button class="line-btn" style="background: #e74c3c;" data-color="#e74c3c">R</button>
        <button class="line-btn" style="background: #3498db;" data-color="#3498db">B</button>
        <button class="line-btn" style="background: #2ecc71;" data-color="#2ecc71">G</button>
    </div>

    <div id="info">
        <div>🚇 Mini Metro Clone</div>
        <div style="font-size: 12px; margin-top: 10px;">
            Click and drag to build lines<br>
            Connect multiple stations per line<br>
            Manage passenger flow efficiently
        </div>
    </div>

    <div id="upgrades"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameState = {
            week: 1,
            score: 0,
            linesAvailable: 3,
            trainsAvailable: 6,
            interchangesAvailable: 1,
            gameOver: false,
            paused: false,
            selectedLine: '#e74c3c',
            isDrawing: false,
            currentPath: [],
            upgradesPurchased: 0,
            maxUpgradesPerWeek: 1
        };

        // Game objects
        let stations = [];
        let lines = {};
        let trains = [];
        let passengers = [];
        let gameTime = 0;
        let weekTimer = 0;

        // Station shapes
        const shapes = ['circle', 'square', 'triangle', 'diamond', 'pentagon', 'star'];
        const shapeColors = {
            circle: '#f39c12',
            square: '#9b59b6',
            triangle: '#e67e22',
            diamond: '#1abc9c',
            pentagon: '#e91e63',
            star: '#ff9800'
        };

        // --- Drawing routes between stations (shapes) ---
        let highlightedSegment = null;

        // --- Draw lines (original) ---
        function drawLines() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.path.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.path[0].x, line.path[0].y);
                    for (let i = 1; i < line.path.length; i++) {
                        ctx.lineTo(line.path[i].x, line.path[i].y);
                    }
                    ctx.stroke();
                }
            });
        }

        // --- Visual feedback for segment selection ---
        canvas.addEventListener('mousemove', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (!drawingRoute) {
                const color = gameState.selectedLine;
                const seg = getNearestLineSegment(x, y, color);
                highlightedSegment = seg ? { color, segIdx: seg.segIdx } : null;
            }
        });
        canvas.addEventListener('mouseleave', () => { highlightedSegment = null; });

        // Patch drawLines to highlight segment
        const origDrawLines = drawLines;
        drawLines = function() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.path.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(line.path[0].x, line.path[0].y);
                    for (let i = 1; i < line.path.length; i++) {
                        ctx.lineTo(line.path[i].x, line.path[i].y);
                    }
                    ctx.stroke();
                    // Highlight segment if needed
                    if (highlightedSegment && highlightedSegment.color === color) {
                        const i = highlightedSegment.segIdx;
                        ctx.save();
                        ctx.strokeStyle = '#fffbe6';
                        ctx.lineWidth = 12;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(line.path[i].x, line.path[i].y);
                        ctx.lineTo(line.path[i+1].x, line.path[i+1].y);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            });
        };

        // --- Helper: Ensure minimum distance between stations and UI panels ---
        function isFarFromAllStationsAndUI(x, y, minDist = 100) {
            // Check distance from all stations
            if (!stations.every(s => Math.hypot(s.x - x, s.y - y) >= minDist)) return false;
            // Check distance from UI panels (status, upgrades, info)
            const uiPanels = ['ui', 'upgrades', 'info'].map(id => document.getElementById(id)).filter(Boolean);
            for (const panel of uiPanels) {
                const rect = panel.getBoundingClientRect();
                // Panel bounding box in canvas coordinates
                const panelLeft = rect.left;
                const panelRight = rect.right;
                const panelTop = rect.top;
                const panelBottom = rect.bottom;
                // Convert canvas-relative x/y to screen coordinates
                const canvasRect = canvas.getBoundingClientRect();
                const screenX = x + canvasRect.left;
                const screenY = y + canvasRect.top;
                // Check if within 200px of any edge
                if (
                    screenX > panelLeft - 200 && screenX < panelRight + 200 &&
                    screenY > panelTop - 200 && screenY < panelBottom + 200
                ) {
                    return false;
                }
            }
            return true;
        }
        // --- Patch createStation to enforce min distance from UI ---
        function createStation(x, y, shape) {
            if (!isFarFromAllStationsAndUI(x, y, 100)) return false;
            stations.push({
                x: x,
                y: y,
                shape: shape,
                passengers: [],
                connected: false,
                isInterchange: false
            });
            return true;
        }
        // --- Patch spawnStation to retry for min distance from UI ---
        function spawnStation() {
            if (gameState.gameOver || gameState.paused) return;
            let tries = 0, placed = false;
            while (!placed && tries < 20) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const shape = shapes[Math.floor(Math.random() * Math.min(shapes.length, 3 + Math.floor(gameState.week / 2)))];
                placed = createStation(x, y, shape);
                tries++;
            }
        }

        function spawnPassenger() {
            if (gameState.gameOver || gameState.paused || stations.length < 2) return;
            
            const spawnRate = Math.min(0.7, 0.1 + gameState.week * 0.05);
            if (Math.random() > spawnRate) return;
            
            const fromStation = stations[Math.floor(Math.random() * stations.length)];
            const possibleDestinations = stations.filter(s => s.shape !== fromStation.shape);
            
            if (possibleDestinations.length === 0) return;
            
            const toShape = possibleDestinations[Math.floor(Math.random() * possibleDestinations.length)].shape;
            
            fromStation.passengers.push({
                destination: toShape,
                waitTime: 0,
                id: Math.random().toString(36).substr(2, 9)
            });
        }

        // --- Helper: Compute line segment lengths and total length ---
        function computeLineSegments(line) {
            const segments = [];
            let total = 0;
            for (let i = 1; i < line.stations.length; i++) {
                const a = line.stations[i-1];
                const b = line.stations[i];
                const len = Math.hypot(b.x - a.x, b.y - a.y);
                segments.push(len);
                total += len;
            }
            return { segments, total };
        }

        // --- Helper: Get position along polyline given distance ---
        function getPositionAlongLine(line, distance) {
            const { segments } = computeLineSegments(line);
            let d = distance;
            for (let i = 0; i < segments.length; i++) {
                if (d <= segments[i]) {
                    const a = line.stations[i];
                    const b = line.stations[i+1];
                    const t = segments[i] === 0 ? 0 : d / segments[i];
                    return {
                        x: a.x + (b.x - a.x) * t,
                        y: a.y + (b.y - a.y) * t,
                        angle: Math.atan2(b.y - a.y, b.x - a.x),
                        segment: i,
                        t
                    };
                }
                d -= segments[i];
            }
            // If at end, return last station
            const last = line.stations[line.stations.length-1];
            const prev = line.stations[line.stations.length-2];
            return {
                x: last.x,
                y: last.y,
                angle: Math.atan2(last.y - prev.y, last.x - prev.x),
                segment: segments.length-1,
                t: 1
            };
        }

        // --- Update addTrainsToLines to preserve train positions ---
        function addTrainsToLines() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2) {
                    if (!line.trains || line.trains.length === 0) {
                        // Add one train at start
                        line.trains = [];
                        addTrainToLine(color);
                    }
                }
            });
        }

        function progressWeek() {
            if (gameState.gameOver || gameState.paused) return;
            
            gameState.week++;
            gameState.upgradesPurchased = 0; // Reset upgrades for new week
            updateUpgradeButtons();
            
            // Spawn new stations more frequently in higher weeks
            if (gameState.week % 2 === 0) {
                spawnStation();
            }
            renderUpgradesPanel();
            renderInventoryPanel();
        }

        function buyUpgrade(type) {
            const upgrades = document.getElementById('upgrades');
            if (upgrades && upgrades.classList.contains('collapsed')) return;
            if (gameState.upgradesPurchased >= gameState.maxUpgradesPerWeek) return;
            let upgradeSuccessful = false;
            
            switch (type) {
                case 'train':
                    gameState.trainsAvailable += 2;
                    gameState.upgradesPurchased++;
                    upgradeSuccessful = true;
                    break;
                case 'line':
                    if (gameState.linesAvailable < 6) {
                        gameState.linesAvailable++;
                        upgradeSuccessful = true;
                    }
                    break;
                case 'interchange':
                    gameState.interchangesAvailable++;
                    gameState.upgradesPurchased++;
                    upgradeSuccessful = true;
                    break;
            }
            
            if (upgradeSuccessful) {
                updateUpgradeButtons();
                updateUI();
                renderUpgradesPanel();
                renderInventoryPanel();
                console.log(`Purchased ${type} upgrade. Upgrades used: ${gameState.upgradesPurchased}/${gameState.maxUpgradesPerWeek}`);
            }
        }

        function addNewLine() {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22'];
            const colorLabels = ['R', 'B', 'G', 'Y', 'P', 'O'];
            const newColor = colors[gameState.linesAvailable - 1];
            
            if (newColor && !lines[newColor]) {
                lines[newColor] = { stations: [], path: [], trains: [] };
                
                // Add button for new line
                const controlsDiv = document.getElementById('controls');
                const newBtn = document.createElement('button');
                newBtn.className = 'line-btn';
                newBtn.style.background = newColor;
                newBtn.dataset.color = newColor;
                newBtn.textContent = colorLabels[gameState.linesAvailable - 1];
                
                newBtn.addEventListener('click', () => {
                    document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
                    newBtn.classList.add('active');
                    gameState.selectedLine = newColor;
                });
                
                controlsDiv.appendChild(newBtn);
            }
        }

        function updateUpgradeButtons() {
            const buttons = document.querySelectorAll('.upgrade-btn');
            const maxUpgradesReached = gameState.upgradesPurchased >= gameState.maxUpgradesPerWeek;
            
            buttons.forEach(btn => {
                btn.disabled = maxUpgradesReached;
            });
            
            // Update the upgrade status display, only if elements exist
            const upgradesUsed = document.getElementById('upgradesUsed');
            if (upgradesUsed) upgradesUsed.textContent = gameState.upgradesPurchased;
            const maxUpgrades = document.getElementById('maxUpgrades');
            if (maxUpgrades) maxUpgrades.textContent = gameState.maxUpgradesPerWeek;
        }

        function drawStation(station) {
            const size = 30;
            ctx.fillStyle = shapeColors[station.shape];
            ctx.strokeStyle = station.isInterchange ? '#ffffff' : '#2c3e50';
            ctx.lineWidth = station.isInterchange ? 6 : 4;
            
            ctx.save();
            ctx.translate(station.x, station.y);
            
            switch (station.shape) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'square':
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                    ctx.strokeRect(-size, -size, size * 2, size * 2);
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size, size);
                    ctx.lineTo(size, size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'diamond':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'pentagon':
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'star':
                    ctx.beginPath();
                    for (let i = 0; i < 10; i++) {
                        const angle = (i * Math.PI) / 5 - Math.PI / 2;
                        const radius = i % 2 === 0 ? size : size * 0.5;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
            
            // Draw passenger waiting indicators
            if (station.passengers.length > 0) {
                // Group passengers by destination
                const passengerGroups = {};
                station.passengers.forEach(p => {
                    if (!passengerGroups[p.destination]) {
                        passengerGroups[p.destination] = 0;
                    }
                    passengerGroups[p.destination]++;
                });
                
                // Draw passenger indicators
                const destinations = Object.keys(passengerGroups);
                destinations.forEach((dest, index) => {
                    const count = passengerGroups[dest];
                    const angle = (index * 2 * Math.PI) / destinations.length;
                    const indicatorX = station.x + Math.cos(angle) * 50;
                    const indicatorY = station.y + Math.sin(angle) * 50;
                    
                    // Background for count
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Destination shape
                    ctx.fillStyle = shapeColors[dest];
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    const iconSize = 8;
                    ctx.save();
                    ctx.translate(indicatorX, indicatorY - 5);
                    
                    switch (dest) {
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(0, 0, iconSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'square':
                            ctx.fillRect(-iconSize, -iconSize, iconSize * 2, iconSize * 2);
                            ctx.strokeRect(-iconSize, -iconSize, iconSize * 2, iconSize * 2);
                            break;
                        case 'triangle':
                            ctx.beginPath();
                            ctx.moveTo(0, -iconSize);
                            ctx.lineTo(-iconSize, iconSize);
                            ctx.lineTo(iconSize, iconSize);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'diamond':
                            ctx.beginPath();
                            ctx.moveTo(0, -iconSize);
                            ctx.lineTo(iconSize, 0);
                            ctx.lineTo(0, iconSize);
                            ctx.lineTo(-iconSize, 0);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'pentagon':
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                                const x = Math.cos(angle) * iconSize;
                                const y = Math.sin(angle) * iconSize;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'star':
                            ctx.beginPath();
                            for (let i = 0; i < 10; i++) {
                                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                                const radius = i % 2 === 0 ? iconSize : iconSize * 0.5;
                                const x = Math.cos(angle) * radius;
                                const y = Math.sin(angle) * radius;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                    }
                    
                    ctx.restore();
                    
                    // Count
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(count, indicatorX, indicatorY + 8);
                });
            }
        }

        function updateTrains() {
            if (gameState.paused) return;
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2 && line.trains) {
                    const { segments, total } = computeLineSegments(line);
                    line.trains.forEach(train => {
                        const speed = 2.2; // pixels per frame
                        train.distance += speed * train.direction;
                        // Reverse at ends
                        if (train.distance > total) {
                            train.distance = total - (train.distance - total);
                            train.direction = -1;
                        } else if (train.distance < 0) {
                            train.distance = -train.distance;
                            train.direction = 1;
                        }
                        // Save as fraction for future line changes
                        train.distanceFrac = total === 0 ? 0 : train.distance / total;
                        // Pick up/drop off at stations
                        let d = 0;
                        for (let i = 0; i < segments.length; i++) {
                            if (
                                (train.direction === 1 && Math.abs(train.distance - d) < speed) ||
                                (train.direction === -1 && Math.abs(train.distance - (d + segments[i])) < speed)
                            ) {
                                const station = line.stations[train.direction === 1 ? i : i+1];
                                if (station) {
                                    // Pick up
                                    for (let j = station.passengers.length - 1; j >= 0; j--) {
                                        const passenger = station.passengers[j];
                                        const canPickup = line.stations.some(s => s.shape === passenger.destination);
                                        if (canPickup && train.passengers.length < 6) {
                                            train.passengers.push(passenger);
                                            station.passengers.splice(j, 1);
                                        }
                                    }
                                    // Drop off
                                    if (station.isInterchange) {
                                        // Drop off only correct passengers at interchange
                                        for (let j = train.passengers.length - 1; j >= 0; j--) {
                                            const passenger = train.passengers[j];
                                            if (station.shape === passenger.destination) {
                                                train.passengers.splice(j, 1);
                                                gameState.score += 10;
                                            }
                                        }
                                    } else {
                                        for (let j = train.passengers.length - 1; j >= 0; j--) {
                                            const passenger = train.passengers[j];
                                            if (station.shape === passenger.destination) {
                                                train.passengers.splice(j, 1);
                                                gameState.score += 10;
                                            }
                                        }
                                    }
                                }
                            }
                            d += segments[i];
                        }
                    });
                }
            });
        }

        function drawTrains() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2 && line.trains) {
                    const { total } = computeLineSegments(line);
                    line.trains.forEach(train => {
                        const pos = getPositionAlongLine(line, train.distance);
                        ctx.save();
                        ctx.translate(pos.x, pos.y);
                        ctx.rotate(pos.angle);
                        ctx.fillStyle = color;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        // Rectangle: width 40, height 20, rounded corners
                        const w = 40, h = 20, r = 8;
                        ctx.beginPath();
                        ctx.moveTo(-w/2 + r, -h/2);
                        ctx.lineTo(w/2 - r, -h/2);
                        ctx.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + r);
                        ctx.lineTo(w/2, h/2 - r);
                        ctx.quadraticCurveTo(w/2, h/2, w/2 - r, h/2);
                        ctx.lineTo(-w/2 + r, h/2);
                        ctx.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - r);
                        ctx.lineTo(-w/2, -h/2 + r);
                        ctx.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Draw headlight at front depending on direction
                        ctx.save();
                        if (train.direction === 1) {
                            ctx.translate(w/2 - 6, 0);
                        } else {
                            ctx.translate(-w/2 + 6, 0);
                        }
                        ctx.fillStyle = '#fffbe6';
                        ctx.beginPath();
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        // Draw passenger shapes/colors inside train
                        const px0 = -w/2 + 10, py0 = -h/2 + 10;
                        train.passengers.forEach((p, i) => {
                            ctx.save();
                            ctx.translate(px0 + (i % 3) * 12, py0 + Math.floor(i / 3) * 12);
                            ctx.fillStyle = shapeColors[p.destination];
                            ctx.strokeStyle = '#222';
                            ctx.lineWidth = 1.5;
                            switch (p.destination) {
                                case 'circle':
                                    ctx.beginPath();
                                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'square':
                                    ctx.fillRect(-4, -4, 8, 8);
                                    ctx.strokeRect(-4, -4, 8, 8);
                                    break;
                                case 'triangle':
                                    ctx.beginPath();
                                    ctx.moveTo(0, -4);
                                    ctx.lineTo(-4, 4);
                                    ctx.lineTo(4, 4);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'diamond':
                                    ctx.beginPath();
                                    ctx.moveTo(0, -4);
                                    ctx.lineTo(4, 0);
                                    ctx.lineTo(0, 4);
                                    ctx.lineTo(-4, 0);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'pentagon':
                                    ctx.beginPath();
                                    for (let j = 0; j < 5; j++) {
                                        const angle = (j * 2 * Math.PI) / 5 - Math.PI / 2;
                                        const x = Math.cos(angle) * 4;
                                        const y = Math.sin(angle) * 4;
                                        if (j === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'star':
                                    ctx.beginPath();
                                    for (let j = 0; j < 10; j++) {
                                        const angle = (j * Math.PI) / 5 - Math.PI / 2;
                                        const radius = j % 2 === 0 ? 4 : 2;
                                        const x = Math.cos(angle) * radius;
                                        const y = Math.sin(angle) * radius;
                                        if (j === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                            }
                            ctx.restore();
                        });
                        ctx.restore();
                    });
                }
            });
        }

        function updateUI() {
            const week = document.getElementById('week');
            if (week) week.textContent = gameState.week;
            const score = document.getElementById('score');
            if (score) score.textContent = gameState.score;
            const lines = document.getElementById('lines');
            if (lines) lines.textContent = gameState.linesAvailable;
            const trains = document.getElementById('trains');
            if (trains) trains.textContent = gameState.trainsAvailable;
        }

        function renderInventoryPanel() {
            let html = '';
            if (gameState.trainsAvailable > 0) {
                html += `<button class="upgrade-btn" onclick="showTrainAssignmentUI()">Assign Train (${gameState.trainsAvailable})</button>`;
            }
            if (gameState.interchangesAvailable > 0) {
                html += `<button class="upgrade-btn" onclick="showInterchangeAssignmentUI()">Assign Interchange (${gameState.interchangesAvailable})</button>`;
            }
            document.getElementById('inventoryPanel').innerHTML = html;
        }

        function showGameOver() {
            if (document.getElementById('gameOverScreen')) return;
            const div = document.createElement('div');
            div.id = 'gameOverScreen';
            div.className = 'game-over';
            div.innerHTML = `<h2>Game Over</h2><p>Score: ${gameState.score}</p><button class='restart-btn' onclick='restartGame()'>Restart</button>`;
            document.body.appendChild(div);
        }
        function hideGameOver() {
            const div = document.getElementById('gameOverScreen');
            if (div) div.remove();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLines();
            drawCurrentPath();
            stations.forEach(drawStation);
            updateTrains();
            drawTrains();
            updateUI();
            if (!gameState.gameOver) {
                updatePassengers();
                checkGameOver();
                requestAnimationFrame(gameLoop);
            } else {
                showGameOver();
            }
        }

        function restartGame() {
            hideGameOver();
            // Reset game state
            gameState = {
                week: 1,
                score: 0,
                linesAvailable: 3,
                trainsAvailable: 6,
                interchangesAvailable: 1,
                gameOver: false,
                paused: false,
                selectedLine: '#e74c3c',
                isDrawing: false,
                currentPath: [],
                upgradesPurchased: 0,
                maxUpgradesPerWeek: 1
            };
            stations = [];
            lines = {};
            trains = [];
            passengers = [];
            gameTime = 0;
            weekTimer = 0;
            // Remove extra line buttons
            document.querySelectorAll('.line-btn').forEach((btn, i) => { if (i > 2) btn.remove(); });
            init();
        }

        function getStationAt(x, y) {
            return stations.find(s => Math.hypot(s.x - x, s.y - y) < 30);
        }

        function setActiveLineButton(btn) {
            document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            gameState.selectedLine = btn.dataset.color;
        }

        function setupLineButtonEvents() {
            document.querySelectorAll('.line-btn').forEach(btn => {
                btn.onclick = () => setActiveLineButton(btn);
            });
            // Ensure at least one is active
            const activeBtn = document.querySelector('.line-btn.active');
            if (!activeBtn) {
                const firstBtn = document.querySelector('.line-btn');
                if (firstBtn) setActiveLineButton(firstBtn);
            }
        }

        const origAddNewLine = addNewLine;
        addNewLine = function() {
            origAddNewLine.apply(this, arguments);
            setupLineButtonEvents();
        };

        setupLineButtonEvents();

        let drawingRoute = false;
        let routeStartStation = null;
        let routeStartSegment = null;

        canvas.addEventListener('mousedown', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const station = getStationAt(x, y);
            if (station) {
                drawingRoute = true;
                routeStartStation = station;
                routeStartSegment = null;
                gameState.currentPath = [{ x: station.x, y: station.y }];
            } else {
                // Try to start from a line segment
                const color = gameState.selectedLine;
                const seg = getNearestLineSegment(x, y, color);
                if (seg) {
                    drawingRoute = true;
                    routeStartStation = null;
                    routeStartSegment = seg.segIdx;
                    gameState.currentPath = [seg.proj];
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            gameState.currentPath[1] = { x, y };
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const endStation = getStationAt(x, y);
            const color = gameState.selectedLine;
            const line = lines[color];
            if (endStation && line) {
                if (routeStartStation && endStation !== routeStartStation) {
                    // Existing logic: add to end if not present
                    if (line.stations.length === 0 || line.stations[line.stations.length-1] !== routeStartStation) {
                        line.stations.push(routeStartStation);
                    }
                    if (!line.stations.includes(endStation)) {
                        line.stations.push(endStation);
                    }
                } else if (routeStartSegment !== null && !line.stations.includes(endStation)) {
                    // Insert station into the line at the correct position
                    line.stations.splice(routeStartSegment + 1, 0, endStation);
                }
                // Update path
                line.path = line.stations.map(s => ({ x: s.x, y: s.y }));
                reassignTrainPositions(line);
                addTrainsToLines();
            }
            drawingRoute = false;
            routeStartStation = null;
            routeStartSegment = null;
            gameState.currentPath = [];
        });

        canvas.addEventListener('touchstart', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const station = getStationAt(x, y);
            if (station) {
                drawingRoute = true;
                routeStartStation = station;
                routeStartSegment = null;
                gameState.currentPath = [{ x: station.x, y: station.y }];
            } else {
                const color = gameState.selectedLine;
                const seg = getNearestLineSegment(x, y, color);
                if (seg) {
                    drawingRoute = true;
                    routeStartStation = null;
                    routeStartSegment = seg.segIdx;
                    gameState.currentPath = [seg.proj];
                }
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            gameState.currentPath[1] = { x, y };
        });
        canvas.addEventListener('touchend', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = gameState.currentPath[1] ? gameState.currentPath[1].x : gameState.currentPath[0].x;
            const y = gameState.currentPath[1] ? gameState.currentPath[1].y : gameState.currentPath[0].y;
            const endStation = getStationAt(x, y);
            const color = gameState.selectedLine;
            const line = lines[color];
            if (endStation && line) {
                if (routeStartStation && endStation !== routeStartStation) {
                    if (line.stations.length === 0 || line.stations[line.stations.length-1] !== routeStartStation) {
                        line.stations.push(routeStartStation);
                    }
                    if (!line.stations.includes(endStation)) {
                        line.stations.push(endStation);
                    }
                } else if (routeStartSegment !== null && !line.stations.includes(endStation)) {
                    line.stations.splice(routeStartSegment + 1, 0, endStation);
                }
                line.path = line.stations.map(s => ({ x: s.x, y: s.y }));
                reassignTrainPositions(line);
                addTrainsToLines();
            }
            drawingRoute = false;
            routeStartStation = null;
            routeStartSegment = null;
            gameState.currentPath = [];
        });

        function togglePause() {
            gameState.paused = !gameState.paused;
            if (!gameState.paused && !gameState.gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        function init() {
            // Clear previous intervals if any
            if (passengerInterval) clearInterval(passengerInterval);
            if (stationInterval) clearInterval(stationInterval);
            if (weekInterval) clearInterval(weekInterval);

            // Reset game objects
            stations = [];
            lines = {};
            trains = [];
            passengers = [];
            gameTime = 0;
            weekTimer = 0;

            // Place 3 initial stations randomly but efficiently spaced
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 180;
            const shapesInit = ['circle', 'square', 'triangle'];
            for (let i = 0; i < 3; i++) {
                let angle = Math.random() * Math.PI * 2 + i * (2 * Math.PI / 3);
                let x = centerX + Math.cos(angle) * radius;
                let y = centerY + Math.sin(angle) * radius;
                // Ensure not too close to UI panels or each other
                let tries = 0;
                while ((!isFarFromAllStationsAndUI(x, y, 120) || stations.some(s => Math.hypot(s.x - x, s.y - y) < 120)) && tries < 20) {
                    angle += Math.PI / 6;
                    x = centerX + Math.cos(angle) * radius;
                    y = centerY + Math.sin(angle) * radius;
                    tries++;
                }
                createStation(x, y, shapesInit[i]);
            }

            // Initialize lines with trains
            lines = {
                '#e74c3c': { stations: [], path: [], trains: [] },
                '#3498db': { stations: [], path: [], trains: [] },
                '#2ecc71': { stations: [], path: [], trains: [] }
            };
            addTrainsToLines();

            // Start game loop
            gameLoop();

            // Spawn passengers periodically
            passengerInterval = setInterval(spawnPassenger, 3000);
            // Spawn new stations less frequently
            stationInterval = setInterval(spawnStation, 30000);
            // Week progression
            weekInterval = setInterval(progressWeek, 60000); // 1 minute = 1 week

            // Initial UI update
            renderUpgradesPanel();
            updateUpgradeButtons();
            updateUI();
            renderInventoryPanel();
        }

        window.addEventListener('load', () => {
            init();
        });

        window.addEventListener('DOMContentLoaded', () => {
            const lineBtns = document.querySelectorAll('.line-btn');
            lineBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.selectedLine = btn.dataset.color;
                });
            });
            // Set the first line as active by default
            if (lineBtns[0]) {
                lineBtns[0].classList.add('active');
                gameState.selectedLine = lineBtns[0].dataset.color;
            }
        });

        function showTrainAssignmentUI() {
            let modal = document.getElementById('trainAssignModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'trainAssignModal';
                modal.style.position = 'fixed';
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.background = 'rgba(0,0,0,0.95)';
                modal.style.padding = '30px 20px';
                modal.style.borderRadius = '12px';
                modal.style.zIndex = 9999;
                modal.style.textAlign = 'center';
                modal.style.boxShadow = '0 8px 32px #0008';
                modal.innerHTML = `<h3 style='margin-top:0'>Assign New Train</h3><div id='trainAssignBtns'></div><div style='margin-top:10px;font-size:13px;color:#ccc'>Choose a line to add a train. (${gameState.trainsAvailable})</div>`;
                document.body.appendChild(modal);
            }
            // Update button list
            const btnsDiv = modal.querySelector('#trainAssignBtns');
            btnsDiv.innerHTML = '';
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2) {
                    const btn = document.createElement('button');
                    btn.textContent = colorToLabel(color);
                    btn.style.background = color;
                    btn.style.color = '#fff';
                    btn.style.fontWeight = 'bold';
                    btn.style.margin = '0 8px 8px 0';
                    btn.style.padding = '10px 18px';
                    btn.style.border = 'none';
                    btn.style.borderRadius = '8px';
                    btn.style.fontSize = '18px';
                    btn.style.cursor = 'pointer';
                    btn.onclick = () => {
                        btnsDiv.querySelectorAll('button').forEach(b => b.disabled = true);
                        addTrainToLine(color);
                        gameState.trainsAvailable--;
                        renderInventoryPanel();
                        hideTrainAssignmentUI();
                    };
                    btnsDiv.appendChild(btn);
                }
            });
            modal.querySelector('div[style*="color:#ccc"]').textContent = `Choose a line to add a train. (${gameState.trainsAvailable})`;
        }
        function hideTrainAssignmentUI() {
            const modal = document.getElementById('trainAssignModal');
            if (modal) modal.remove();
        }
        function colorToLabel(color) {
            const map = {
                '#e74c3c': 'R', '#3498db': 'B', '#2ecc71': 'G', '#f39c12': 'Y', '#9b59b6': 'P', '#e67e22': 'O'
            };
            return map[color] || color;
        }
        function addTrainToLine(color) {
            const line = lines[color];
            if (!line || line.stations.length < 2) return;
            const { total } = computeLineSegments(line);
            const pos = Math.random() * total;
            line.trains.push({
                distance: pos,
                distanceFrac: total === 0 ? 0 : pos / total,
                direction: 1,
                passengers: [],
                color: color
            });
        }

        function showInterchangeAssignmentUI() {
            let modal = document.getElementById('interchangeAssignModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'interchangeAssignModal';
                modal.style.position = 'fixed';
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.background = 'rgba(0,0,0,0.95)';
                modal.style.padding = '30px 20px';
                modal.style.borderRadius = '12px';
                modal.style.zIndex = 9999;
                modal.style.textAlign = 'center';
                modal.style.boxShadow = '0 8px 32px #0008';
                modal.innerHTML = `<h3 style='margin-top:0'>Assign Interchange</h3><div style='margin-top:10px;font-size:13px;color:#ccc'>Click a station to upgrade to an interchange.</div>`;
                document.body.appendChild(modal);
            }
            canvas.style.cursor = 'pointer';
            function handleInterchangeClick(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const station = stations.find(s => Math.hypot(s.x - x, s.y - y) < 30);
                if (station && !station.isInterchange && gameState.interchangesAvailable > 0) {
                    station.isInterchange = true;
                    gameState.interchangesAvailable--;
                    renderInventoryPanel();
                    hideInterchangeAssignmentUI();
                    updateUI();
                }
            }
            canvas.addEventListener('mousedown', handleInterchangeClick, { once: true });
        }
        function hideInterchangeAssignmentUI() {
            const modal = document.getElementById('interchangeAssignModal');
            if (modal) modal.remove();
            canvas.style.cursor = '';
            canvas.removeEventListener('mousedown', handleInterchangeClick);
        }

        function setupCollapsiblePanels() {
            // Upgrades panel
            const upgrades = document.getElementById('upgrades');
            if (upgrades && !document.getElementById('collapseUpgradesBtn')) {
                const btn = document.createElement('button');
                btn.id = 'collapseUpgradesBtn';
                btn.textContent = '−';
                btn.style.position = 'absolute';
                btn.style.top = '8px';
                btn.style.right = '8px';
                btn.style.background = '#222';
                btn.style.color = '#fff';
                btn.style.border = 'none';
                btn.style.borderRadius = '50%';
                btn.style.width = '24px';
                btn.style.height = '24px';
                btn.style.cursor = 'pointer';
                btn.style.fontSize = '18px';
                btn.onclick = function() {
                    if (upgrades.classList.contains('collapsed')) {
                        upgrades.classList.remove('collapsed');
                        btn.textContent = '−';
                    } else {
                        upgrades.classList.add('collapsed');
                        btn.textContent = '+';
                    }
                };
                upgrades.style.position = 'relative';
                upgrades.appendChild(btn);
            }
            // Info/help panel
            const info = document.getElementById('info');
            if (info && !document.getElementById('collapseInfoBtn')) {
                const btn = document.createElement('button');
                btn.id = 'collapseInfoBtn';
                btn.textContent = '−';
                btn.style.position = 'absolute';
                btn.style.top = '8px';
                btn.style.right = '8px';
                btn.style.background = '#222';
                btn.style.color = '#fff';
                btn.style.border = 'none';
                btn.style.borderRadius = '50%';
                btn.style.width = '24px';
                btn.style.height = '24px';
                btn.style.cursor = 'pointer';
                btn.style.fontSize = '18px';
                btn.onclick = function() {
                    if (info.classList.contains('collapsed')) {
                        info.classList.remove('collapsed');
                        btn.textContent = '−';
                    } else {
                        info.classList.add('collapsed');
                        btn.textContent = '+';
                    }
                };
                info.style.position = 'relative';
                info.appendChild(btn);
            }
        }
        window.addEventListener('DOMContentLoaded', setupCollapsiblePanels);
        window.addEventListener('load', setupCollapsiblePanels);

        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('upgrades')?.classList.remove('collapsed');
            document.getElementById('info')?.classList.remove('collapsed');
            // Set collapse buttons to '−' if present
            const upBtn = document.getElementById('collapseUpgradesBtn');
            if (upBtn) upBtn.textContent = '−';
            const infoBtn = document.getElementById('collapseInfoBtn');
            if (infoBtn) infoBtn.textContent = '−';
        });

        function getNearestLineSegment(x, y, color) {
            const line = lines[color];
            if (!line || line.path.length < 2) return null;
            let minDist = Infinity, segIdx = -1, proj = null;
            for (let i = 0; i < line.path.length - 1; i++) {
                const a = line.path[i], b = line.path[i+1];
                // Project point onto segment
                const dx = b.x - a.x, dy = b.y - a.y;
                const len2 = dx*dx + dy*dy;
                if (len2 === 0) continue;
                let t = ((x - a.x) * dx + (y - a.y) * dy) / len2;
                t = Math.max(0, Math.min(1, t));
                const px = a.x + t * dx, py = a.y + t * dy;
                const dist = Math.hypot(px - x, py - y);
                if (dist < minDist) {
                    minDist = dist;
                    segIdx = i;
                    proj = { x: px, y: py };
                }
            }
            if (minDist < 20) return { segIdx, proj };
            return null;
        }

        function drawCurrentPath() {
            if (gameState.currentPath && gameState.currentPath.length > 1) {
                ctx.save();
                ctx.strokeStyle = gameState.selectedLine;
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.moveTo(gameState.currentPath[0].x, gameState.currentPath[0].y);
                for (let i = 1; i < gameState.currentPath.length; i++) {
                    ctx.lineTo(gameState.currentPath[i].x, gameState.currentPath[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        // --- Update passengers: increment wait time, remove if waited too long ---
        function updatePassengers() {
            const maxWait = 60; // seconds
            stations.forEach(station => {
                for (let i = station.passengers.length - 1; i >= 0; i--) {
                    const p = station.passengers[i];
                    p.waitTime += 1 / 60; // assuming 60fps
                    if (p.waitTime > maxWait) {
                        // Remove passenger (could trigger game over in future)
                        station.passengers.splice(i, 1);
                    }
                }
            });
        }

        // --- Reassign train positions after line change ---
        function reassignTrainPositions(line) {
            if (!line.trains || line.trains.length === 0) return;
            const { total } = computeLineSegments(line);
            line.trains.forEach(train => {
                train.distance = train.distanceFrac * total;
            });
        }

        // --- Check for game over: too many passengers at a station ---
        function checkGameOver() {
            const maxWait = 6;
            for (const station of stations) {
                if (station.passengers.length > maxWait) {
                    gameState.gameOver = true;
                    return;
                }
            }
        }
    </script>
</body>
</html>