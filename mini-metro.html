<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8268518333873371"
      crossorigin="anonymous"
    ></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-9LBRY92EL5"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-9LBRY92EL5");

      // Simple mobile detection
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);

      // Place this near the top of the script, after other let/const declarations
      let passengerInterval = null;
      let stationInterval = null;
      let weekInterval = null;

      // --- Pending trains to assign ---
      let pendingTrains = 0;
    </script>
    <title>Mini Metro Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2c3e50;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background: #34495e;
            cursor: crosshair;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .line-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 16px;
            touch-action: manipulation;
        }

        .line-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .line-btn.active {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background: #34495e;
            color: white;
            font-size: 20px;
            touch-action: manipulation;
        }

        .control-btn:hover {
            background: #4a5f7a;
        }

        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-align: center;
            font-size: 12px;
            max-width: 150px;
        }

        #upgrades {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .upgrade-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .upgrade-btn:hover:not(:disabled) {
            background: #2ecc71;
        }

        .upgrade-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .upgrade-status {
            font-size: 11px;
            color: #bdc3c7;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 8px;
            }
            
            #info {
                font-size: 10px;
                padding: 8px;
                max-width: 120px;
            }
            
            #upgrades {
                min-width: 150px;
                padding: 10px;
            }
            
            .line-btn, .control-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }

        .stat {
            margin: 5px 0;
            font-size: 14px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(15px);
        }

        .restart-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: background 0.3s ease;
        }

        .restart-btn:hover {
            background: #c0392b;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="stat">Week: <span id="week">1</span></div>
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Lines: <span id="lines">3</span></div>
        <div class="stat">Trains: <span id="trains">6</span></div>
        <div class="stat">Tunnels: <span id="tunnels">2</span></div>
        <div class="stat">Bridges: <span id="bridges">2</span></div>
    </div>

    <div id="controls">
        <button class="control-btn" id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è</button>
        <button class="line-btn" style="background: #e74c3c;" data-color="#e74c3c">R</button>
        <button class="line-btn" style="background: #3498db;" data-color="#3498db">B</button>
        <button class="line-btn" style="background: #2ecc71;" data-color="#2ecc71">G</button>
    </div>

    <div id="info">
        <div>üöá Mini Metro Clone</div>
        <div style="font-size: 12px; margin-top: 10px;">
            Click and drag to build lines<br>
            Connect multiple stations per line<br>
            Manage passenger flow efficiently
        </div>
    </div>

    <div id="upgrades">
        <h3 style="margin-top: 0;">Weekly Upgrades</h3>
        <div class="upgrade-status">
            Upgrades used: <span id="upgradesUsed">0</span>/<span id="maxUpgrades">1</span>
        </div>
        <div class="upgrade-item">
            <span>+1 Line</span>
            <button class="upgrade-btn" onclick="buyUpgrade('line')">Buy</button>
        </div>
        <div class="upgrade-item">
            <span>+2 Trains</span>
            <button class="upgrade-btn" onclick="buyUpgrade('train')">Buy</button>
        </div>
        <div class="upgrade-item">
            <span>+1 Tunnel</span>
            <button class="upgrade-btn" onclick="buyUpgrade('tunnel')">Buy</button>
        </div>
        <div class="upgrade-item">
            <span>+1 Bridge</span>
            <button class="upgrade-btn" onclick="buyUpgrade('bridge')">Buy</button>
        </div>
        <div class="upgrade-item">
            <span>+1 Interchange</span>
            <button class="upgrade-btn" onclick="buyUpgrade('interchange')">Buy</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameState = {
            week: 1,
            score: 0,
            linesAvailable: 3,
            trainsAvailable: 6,
            tunnelsAvailable: 2,
            bridgesAvailable: 2,
            interchangesAvailable: 1,
            gameOver: false,
            paused: false,
            selectedLine: '#e74c3c',
            isDrawing: false,
            currentPath: [],
            upgradesPurchased: 0,
            maxUpgradesPerWeek: 1
        };

        // Game objects
        let stations = [];
        let lines = {};
        let trains = [];
        let passengers = [];
        let gameTime = 0;
        let weekTimer = 0;

        // Station shapes
        const shapes = ['circle', 'square', 'triangle', 'diamond', 'pentagon', 'star'];
        const shapeColors = {
            circle: '#f39c12',
            square: '#9b59b6',
            triangle: '#e67e22',
            diamond: '#1abc9c',
            pentagon: '#e91e63',
            star: '#ff9800'
        };

        // Replace the init function with this version:
        function init() {
            // Clear previous intervals if any
            if (passengerInterval) clearInterval(passengerInterval);
            if (stationInterval) clearInterval(stationInterval);
            if (weekInterval) clearInterval(weekInterval);

            // Create initial stations
            createStation(200, 200, 'circle');
            createStation(400, 300, 'square');
            createStation(600, 250, 'triangle');
            
            // Initialize lines with trains
            lines = {
                '#e74c3c': { stations: [], path: [], trains: [] },
                '#3498db': { stations: [], path: [], trains: [] },
                '#2ecc71': { stations: [], path: [], trains: [] }
            };

            // Create initial trains
            addTrainsToLines();

            // Start game loop
            gameLoop();

            // Spawn passengers periodically
            passengerInterval = setInterval(spawnPassenger, 3000);

            // Spawn new stations less frequently
            stationInterval = setInterval(spawnStation, 30000);

            // Week progression
            weekInterval = setInterval(progressWeek, 60000); // 1 minute = 1 week

            // Initial UI update
            updateUpgradeButtons();
            updateUI();
        }

        // --- Helper: Ensure minimum distance between stations ---
        function isFarFromAllStations(x, y, minDist = 100) {
            return stations.every(s => Math.hypot(s.x - x, s.y - y) >= minDist);
        }
        // --- Patch createStation to enforce min distance ---
        function createStation(x, y, shape) {
            if (!isFarFromAllStations(x, y)) return false;
            stations.push({
                x: x,
                y: y,
                shape: shape,
                passengers: [],
                connected: false,
                isInterchange: false
            });
            return true;
        }
        // --- Patch spawnStation to retry for min distance ---
        function spawnStation() {
            if (gameState.gameOver || gameState.paused) return;
            let tries = 0, placed = false;
            while (!placed && tries < 20) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const shape = shapes[Math.floor(Math.random() * Math.min(shapes.length, 3 + Math.floor(gameState.week / 2)))];
                placed = createStation(x, y, shape);
                tries++;
            }
        }

        function spawnPassenger() {
            if (gameState.gameOver || gameState.paused || stations.length < 2) return;
            
            const spawnRate = Math.min(0.7, 0.1 + gameState.week * 0.05);
            if (Math.random() > spawnRate) return;
            
            const fromStation = stations[Math.floor(Math.random() * stations.length)];
            const possibleDestinations = stations.filter(s => s.shape !== fromStation.shape);
            
            if (possibleDestinations.length === 0) return;
            
            const toShape = possibleDestinations[Math.floor(Math.random() * possibleDestinations.length)].shape;
            
            fromStation.passengers.push({
                destination: toShape,
                waitTime: 0,
                id: Math.random().toString(36).substr(2, 9)
            });
        }

        // --- Helper: Compute line segment lengths and total length ---
        function computeLineSegments(line) {
            const segments = [];
            let total = 0;
            for (let i = 1; i < line.stations.length; i++) {
                const a = line.stations[i-1];
                const b = line.stations[i];
                const len = Math.hypot(b.x - a.x, b.y - a.y);
                segments.push(len);
                total += len;
            }
            return { segments, total };
        }

        // --- Helper: Get position along polyline given distance ---
        function getPositionAlongLine(line, distance) {
            const { segments } = computeLineSegments(line);
            let d = distance;
            for (let i = 0; i < segments.length; i++) {
                if (d <= segments[i]) {
                    const a = line.stations[i];
                    const b = line.stations[i+1];
                    const t = segments[i] === 0 ? 0 : d / segments[i];
                    return {
                        x: a.x + (b.x - a.x) * t,
                        y: a.y + (b.y - a.y) * t,
                        angle: Math.atan2(b.y - a.y, b.x - a.x),
                        segment: i,
                        t
                    };
                }
                d -= segments[i];
            }
            // If at end, return last station
            const last = line.stations[line.stations.length-1];
            const prev = line.stations[line.stations.length-2];
            return {
                x: last.x,
                y: last.y,
                angle: Math.atan2(last.y - prev.y, last.x - prev.x),
                segment: segments.length-1,
                t: 1
            };
        }

        // --- Update addTrainsToLines to preserve train positions ---
        function addTrainsToLines() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2) {
                    if (!line.trains || line.trains.length === 0) {
                        // Add one train at start
                        line.trains = [];
                        addTrainToLine(color);
                    }
                }
            });
        }

        function progressWeek() {
            if (gameState.gameOver || gameState.paused) return;
            
            gameState.week++;
            gameState.upgradesPurchased = 0; // Reset upgrades for new week
            updateUpgradeButtons();
            
            // Spawn new stations more frequently in higher weeks
            if (gameState.week % 2 === 0) {
                spawnStation();
            }
        }

        function buyUpgrade(type) {
            if (type === 'train') {
                if (gameState.upgradesPurchased >= gameState.maxUpgradesPerWeek) return;
                pendingTrains += 2;
                showTrainAssignmentUI();
                gameState.upgradesPurchased++;
                updateUpgradeButtons();
                updateUI();
                return;
            }
            let upgradeSuccessful = false;
            
            switch (type) {
                case 'line':
                    if (gameState.linesAvailable < 6) {
                        gameState.linesAvailable++;
                        addNewLine();
                        upgradeSuccessful = true;
                    }
                    break;
                case 'tunnel':
                    gameState.tunnelsAvailable++;
                    upgradeSuccessful = true;
                    break;
                case 'bridge':
                    gameState.bridgesAvailable++;
                    upgradeSuccessful = true;
                    break;
                case 'interchange':
                    if (gameState.interchangesAvailable > 0) {
                        showInterchangeAssignmentUI();
                    }
                    break;
            }
            
            if (upgradeSuccessful) {
                updateUpgradeButtons();
                updateUI(); // Update the UI to show new values
                console.log(`Purchased ${type} upgrade. Upgrades used: ${gameState.upgradesPurchased}/${gameState.maxUpgradesPerWeek}`);
            }
        }

        function addNewLine() {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22'];
            const colorLabels = ['R', 'B', 'G', 'Y', 'P', 'O'];
            const newColor = colors[gameState.linesAvailable - 1];
            
            if (newColor && !lines[newColor]) {
                lines[newColor] = { stations: [], path: [], trains: [] };
                
                // Add button for new line
                const controlsDiv = document.getElementById('controls');
                const newBtn = document.createElement('button');
                newBtn.className = 'line-btn';
                newBtn.style.background = newColor;
                newBtn.dataset.color = newColor;
                newBtn.textContent = colorLabels[gameState.linesAvailable - 1];
                
                newBtn.addEventListener('click', () => {
                    document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
                    newBtn.classList.add('active');
                    gameState.selectedLine = newColor;
                });
                
                controlsDiv.appendChild(newBtn);
            }
        }

        function updateUpgradeButtons() {
            const buttons = document.querySelectorAll('.upgrade-btn');
            const maxUpgradesReached = gameState.upgradesPurchased >= gameState.maxUpgradesPerWeek;
            
            buttons.forEach(btn => {
                btn.disabled = maxUpgradesReached;
            });
            
            // Update the upgrade status display
            document.getElementById('upgradesUsed').textContent = gameState.upgradesPurchased;
            document.getElementById('maxUpgrades').textContent = gameState.maxUpgradesPerWeek;
        }

        function drawStation(station) {
            const size = 30;
            ctx.fillStyle = shapeColors[station.shape];
            ctx.strokeStyle = station.isInterchange ? '#ffffff' : '#2c3e50';
            ctx.lineWidth = station.isInterchange ? 6 : 4;
            
            ctx.save();
            ctx.translate(station.x, station.y);
            
            switch (station.shape) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'square':
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                    ctx.strokeRect(-size, -size, size * 2, size * 2);
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size, size);
                    ctx.lineTo(size, size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'diamond':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'pentagon':
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'star':
                    ctx.beginPath();
                    for (let i = 0; i < 10; i++) {
                        const angle = (i * Math.PI) / 5 - Math.PI / 2;
                        const radius = i % 2 === 0 ? size : size * 0.5;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
            
            // Draw passenger waiting indicators
            if (station.passengers.length > 0) {
                // Group passengers by destination
                const passengerGroups = {};
                station.passengers.forEach(p => {
                    if (!passengerGroups[p.destination]) {
                        passengerGroups[p.destination] = 0;
                    }
                    passengerGroups[p.destination]++;
                });
                
                // Draw passenger indicators
                const destinations = Object.keys(passengerGroups);
                destinations.forEach((dest, index) => {
                    const count = passengerGroups[dest];
                    const angle = (index * 2 * Math.PI) / destinations.length;
                    const indicatorX = station.x + Math.cos(angle) * 50;
                    const indicatorY = station.y + Math.sin(angle) * 50;
                    
                    // Background for count
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Destination shape
                    ctx.fillStyle = shapeColors[dest];
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    const iconSize = 8;
                    ctx.save();
                    ctx.translate(indicatorX, indicatorY - 5);
                    
                    switch (dest) {
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(0, 0, iconSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'square':
                            ctx.fillRect(-iconSize, -iconSize, iconSize * 2, iconSize * 2);
                            ctx.strokeRect(-iconSize, -iconSize, iconSize * 2, iconSize * 2);
                            break;
                        case 'triangle':
                            ctx.beginPath();
                            ctx.moveTo(0, -iconSize);
                            ctx.lineTo(-iconSize, iconSize);
                            ctx.lineTo(iconSize, iconSize);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'diamond':
                            ctx.beginPath();
                            ctx.moveTo(0, -iconSize);
                            ctx.lineTo(iconSize, 0);
                            ctx.lineTo(0, iconSize);
                            ctx.lineTo(-iconSize, 0);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'pentagon':
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                                const x = Math.cos(angle) * iconSize;
                                const y = Math.sin(angle) * iconSize;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                        case 'star':
                            ctx.beginPath();
                            for (let i = 0; i < 10; i++) {
                                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                                const radius = i % 2 === 0 ? iconSize : iconSize * 0.5;
                                const x = Math.cos(angle) * radius;
                                const y = Math.sin(angle) * radius;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            break;
                    }
                    
                    ctx.restore();
                    
                    // Count
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(count, indicatorX, indicatorY + 8);
                });
            }
        }

        function drawLines() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.path.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(line.path[0].x, line.path[0].y);
                    for (let i = 1; i < line.path.length; i++) {
                        ctx.lineTo(line.path[i].x, line.path[i].y);
                    }
                    ctx.stroke();
                }
            });
        }

        // --- Patch updateTrains: drop all passengers at interchanges ---
        function updateTrains() {
            if (gameState.paused) return;
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2 && line.trains) {
                    const { segments, total } = computeLineSegments(line);
                    line.trains.forEach(train => {
                        const speed = 2.2; // pixels per frame
                        train.distance += speed * train.direction;
                        // Reverse at ends
                        if (train.distance > total) {
                            train.distance = total - (train.distance - total);
                            train.direction = -1;
                        } else if (train.distance < 0) {
                            train.distance = -train.distance;
                            train.direction = 1;
                        }
                        // Save as fraction for future line changes
                        train.distanceFrac = total === 0 ? 0 : train.distance / total;
                        // Pick up/drop off at stations
                        let d = 0;
                        for (let i = 0; i < segments.length; i++) {
                            if (
                                (train.direction === 1 && Math.abs(train.distance - d) < speed) ||
                                (train.direction === -1 && Math.abs(train.distance - (d + segments[i])) < speed)
                            ) {
                                const station = line.stations[train.direction === 1 ? i : i+1];
                                if (station) {
                                    // Pick up
                                    for (let j = station.passengers.length - 1; j >= 0; j--) {
                                        const passenger = station.passengers[j];
                                        const canPickup = line.stations.some(s => s.shape === passenger.destination);
                                        if (canPickup && train.passengers.length < 6) {
                                            train.passengers.push(passenger);
                                            station.passengers.splice(j, 1);
                                        }
                                    }
                                    // Drop off
                                    if (station.isInterchange) {
                                        // Drop all passengers at interchange
                                        gameState.score += train.passengers.length * 10;
                                        train.passengers = [];
                                    } else {
                                        for (let j = train.passengers.length - 1; j >= 0; j--) {
                                            const passenger = train.passengers[j];
                                            if (station.shape === passenger.destination) {
                                                train.passengers.splice(j, 1);
                                                gameState.score += 10;
                                            }
                                        }
                                    }
                                }
                            }
                            d += segments[i];
                        }
                    });
                }
            });
        }

        // --- Update drawTrains to show passenger shapes/colors ---
        function drawTrains() {
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2 && line.trains) {
                    const { total } = computeLineSegments(line);
                    line.trains.forEach(train => {
                        const pos = getPositionAlongLine(line, train.distance);
                        ctx.save();
                        ctx.translate(pos.x, pos.y);
                        ctx.rotate(pos.angle);
                        ctx.fillStyle = color;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        // Rectangle: width 40, height 20, rounded corners
                        const w = 40, h = 20, r = 8;
                        ctx.beginPath();
                        ctx.moveTo(-w/2 + r, -h/2);
                        ctx.lineTo(w/2 - r, -h/2);
                        ctx.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + r);
                        ctx.lineTo(w/2, h/2 - r);
                        ctx.quadraticCurveTo(w/2, h/2, w/2 - r, h/2);
                        ctx.lineTo(-w/2 + r, h/2);
                        ctx.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - r);
                        ctx.lineTo(-w/2, -h/2 + r);
                        ctx.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Draw headlight at front depending on direction
                        ctx.save();
                        if (train.direction === 1) {
                            ctx.translate(w/2 - 6, 0);
                        } else {
                            ctx.translate(-w/2 + 6, 0);
                        }
                        ctx.fillStyle = '#fffbe6';
                        ctx.beginPath();
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        // Draw passenger shapes/colors inside train
                        const px0 = -w/2 + 10, py0 = -h/2 + 10;
                        train.passengers.forEach((p, i) => {
                            ctx.save();
                            ctx.translate(px0 + (i % 3) * 12, py0 + Math.floor(i / 3) * 12);
                            ctx.fillStyle = shapeColors[p.destination];
                            ctx.strokeStyle = '#222';
                            ctx.lineWidth = 1.5;
                            switch (p.destination) {
                                case 'circle':
                                    ctx.beginPath();
                                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'square':
                                    ctx.fillRect(-4, -4, 8, 8);
                                    ctx.strokeRect(-4, -4, 8, 8);
                                    break;
                                case 'triangle':
                                    ctx.beginPath();
                                    ctx.moveTo(0, -4);
                                    ctx.lineTo(-4, 4);
                                    ctx.lineTo(4, 4);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'diamond':
                                    ctx.beginPath();
                                    ctx.moveTo(0, -4);
                                    ctx.lineTo(4, 0);
                                    ctx.lineTo(0, 4);
                                    ctx.lineTo(-4, 0);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'pentagon':
                                    ctx.beginPath();
                                    for (let j = 0; j < 5; j++) {
                                        const angle = (j * 2 * Math.PI) / 5 - Math.PI / 2;
                                        const x = Math.cos(angle) * 4;
                                        const y = Math.sin(angle) * 4;
                                        if (j === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                                case 'star':
                                    ctx.beginPath();
                                    for (let j = 0; j < 10; j++) {
                                        const angle = (j * Math.PI) / 5 - Math.PI / 2;
                                        const radius = j % 2 === 0 ? 4 : 2;
                                        const x = Math.cos(angle) * radius;
                                        const y = Math.sin(angle) * radius;
                                        if (j === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.stroke();
                                    break;
                            }
                            ctx.restore();
                        });
                        ctx.restore();
                    });
                }
            });
        }

        function drawCurrentPath() {
            if (gameState.currentPath.length > 1) {
                ctx.strokeStyle = gameState.selectedLine;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.setLineDash([5, 5]);
                
                ctx.beginPath();
                ctx.moveTo(gameState.currentPath[0].x, gameState.currentPath[0].y);
                for (let i = 1; i < gameState.currentPath.length; i++) {
                    ctx.lineTo(gameState.currentPath[i].x, gameState.currentPath[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function updatePassengers() {
            if (gameState.paused) return;
            
            gameTime++;
            
            // Update wait times
            stations.forEach(station => {
                station.passengers.forEach(passenger => {
                    passenger.waitTime++;
                    if (passenger.waitTime > 2400) { // 40 seconds at 60fps
                        gameState.gameOver = true;
                    }
                });
            });
        }

        function checkGameOver() {
            stations.forEach(station => {
                if (station.passengers.length > 12) {
                    gameState.gameOver = true;
                }
            });
        }

        // --- UI Update Function ---
        function updateUI() {
            document.getElementById('week').textContent = gameState.week;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lines').textContent = gameState.linesAvailable;
            document.getElementById('trains').textContent = gameState.trainsAvailable;
            document.getElementById('tunnels').textContent = gameState.tunnelsAvailable;
            document.getElementById('bridges').textContent = gameState.bridgesAvailable;
        }

        // --- Game Over Screen ---
        function showGameOver() {
            if (document.getElementById('gameOverScreen')) return;
            const div = document.createElement('div');
            div.id = 'gameOverScreen';
            div.className = 'game-over';
            div.innerHTML = `<h2>Game Over</h2><p>Score: ${gameState.score}</p><button class='restart-btn' onclick='restartGame()'>Restart</button>`;
            document.body.appendChild(div);
        }
        function hideGameOver() {
            const div = document.getElementById('gameOverScreen');
            if (div) div.remove();
        }

        // --- Game Loop ---
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawLines();
            drawCurrentPath();
            stations.forEach(drawStation);
            updateTrains();
            drawTrains();
            updateUI();
            if (!gameState.gameOver) {
                updatePassengers();
                checkGameOver();
                requestAnimationFrame(gameLoop);
            } else {
                showGameOver();
            }
        }

        // --- Restart Game ---
        function restartGame() {
            hideGameOver();
            // Reset game state
            gameState = {
                week: 1,
                score: 0,
                linesAvailable: 3,
                trainsAvailable: 6,
                tunnelsAvailable: 2,
                bridgesAvailable: 2,
                interchangesAvailable: 1,
                gameOver: false,
                paused: false,
                selectedLine: '#e74c3c',
                isDrawing: false,
                currentPath: [],
                upgradesPurchased: 0,
                maxUpgradesPerWeek: 1
            };
            stations = [];
            lines = {};
            trains = [];
            passengers = [];
            gameTime = 0;
            weekTimer = 0;
            // Remove extra line buttons
            document.querySelectorAll('.line-btn').forEach((btn, i) => { if (i > 2) btn.remove(); });
            init();
        }

        // --- Mouse/Touch Events for Drawing Lines ---
        function getStationAt(x, y) {
            return stations.find(s => Math.hypot(s.x - x, s.y - y) < 30);
        }

        // --- Robust Line Selection and Dynamic Button Handling ---
        function setActiveLineButton(btn) {
            document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            gameState.selectedLine = btn.dataset.color;
        }

        function setupLineButtonEvents() {
            document.querySelectorAll('.line-btn').forEach(btn => {
                btn.onclick = () => setActiveLineButton(btn);
            });
            // Ensure at least one is active
            const activeBtn = document.querySelector('.line-btn.active');
            if (!activeBtn) {
                const firstBtn = document.querySelector('.line-btn');
                if (firstBtn) setActiveLineButton(firstBtn);
            }
        }

        // Patch addNewLine to always call setupLineButtonEvents after adding a new button
        const origAddNewLine = addNewLine;
        addNewLine = function() {
            origAddNewLine.apply(this, arguments);
            setupLineButtonEvents();
        };

        // Initial setup for line buttons
        setupLineButtonEvents();

        // --- Drawing routes between stations (shapes) ---
        let drawingRoute = false;
        let routeStartStation = null;

        canvas.addEventListener('mousedown', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const station = getStationAt(x, y);
            if (station) {
                drawingRoute = true;
                routeStartStation = station;
                gameState.currentPath = [{ x: station.x, y: station.y }];
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            gameState.currentPath[1] = { x, y };
        });

        // --- Helper: Reassign train positions after line path changes ---
        function reassignTrainPositions(line) {
            const oldTrains = line.trains || [];
            const { total: newTotal } = computeLineSegments(line);
            if (line.stations.length < 2) {
                line.trains = [];
                return;
            }
            line.trains = oldTrains.map(train => {
                let frac = train.distanceFrac !== undefined ? train.distanceFrac : 0;
                return {
                    ...train,
                    distance: newTotal * frac,
                    distanceFrac: frac
                };
            });
        }
        // --- Patch mouse/touch up event for path reassignment ---
        canvas.addEventListener('mouseup', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const endStation = getStationAt(x, y);
            if (endStation && routeStartStation && endStation !== routeStartStation) {
                const color = gameState.selectedLine;
                const line = lines[color];
                // Prevent duplicate consecutive stations
                if (line.stations.length === 0 || line.stations[line.stations.length-1] !== routeStartStation) {
                    line.stations.push(routeStartStation);
                }
                if (!line.stations.includes(endStation)) {
                    line.stations.push(endStation);
                }
                // Update path to be the sequence of station coordinates
                line.path = line.stations.map(s => ({ x: s.x, y: s.y }));
                reassignTrainPositions(line);
                addTrainsToLines();
            }
            drawingRoute = false;
            routeStartStation = null;
            gameState.currentPath = [];
        });

        // --- Touch Events for Mobile ---
        canvas.addEventListener('touchstart', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const station = getStationAt(x, y);
            if (station) {
                drawingRoute = true;
                routeStartStation = station;
                gameState.currentPath = [{ x: station.x, y: station.y }];
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            gameState.currentPath[1] = { x, y };
        });
        canvas.addEventListener('touchend', (e) => {
            if (!drawingRoute || gameState.gameOver || gameState.paused) return;
            const rect = canvas.getBoundingClientRect();
            const x = gameState.currentPath[1] ? gameState.currentPath[1].x : gameState.currentPath[0].x;
            const y = gameState.currentPath[1] ? gameState.currentPath[1].y : gameState.currentPath[0].y;
            const endStation = getStationAt(x, y);
            if (endStation && routeStartStation && endStation !== routeStartStation) {
                const color = gameState.selectedLine;
                const line = lines[color];
                if (line.stations.length === 0 || line.stations[line.stations.length-1] !== routeStartStation) {
                    line.stations.push(routeStartStation);
                }
                if (!line.stations.includes(endStation)) {
                    line.stations.push(endStation);
                }
                line.path = line.stations.map(s => ({ x: s.x, y: s.y }));
                reassignTrainPositions(line);
                addTrainsToLines();
            }
            drawingRoute = false;
            routeStartStation = null;
            gameState.currentPath = [];
        });

        // --- Pause Button ---
        function togglePause() {
            gameState.paused = !gameState.paused;
            if (!gameState.paused && !gameState.gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        // --- Start Game on Load ---
        window.addEventListener('load', () => {
            init();
        });

        // Add event listeners for line color selection
        window.addEventListener('DOMContentLoaded', () => {
            const lineBtns = document.querySelectorAll('.line-btn');
            lineBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.line-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.selectedLine = btn.dataset.color;
                });
            });
            // Set the first line as active by default
            if (lineBtns[0]) {
                lineBtns[0].classList.add('active');
                gameState.selectedLine = lineBtns[0].dataset.color;
            }
        });

        // --- Patch showTrainAssignmentUI to prevent multiple clicks ---
        function showTrainAssignmentUI() {
            let modal = document.getElementById('trainAssignModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'trainAssignModal';
                modal.style.position = 'fixed';
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.background = 'rgba(0,0,0,0.95)';
                modal.style.padding = '30px 20px';
                modal.style.borderRadius = '12px';
                modal.style.zIndex = 9999;
                modal.style.textAlign = 'center';
                modal.style.boxShadow = '0 8px 32px #0008';
                modal.innerHTML = `<h3 style='margin-top:0'>Assign New Train</h3><div id='trainAssignBtns'></div><div style='margin-top:10px;font-size:13px;color:#ccc'>Choose a line to add a train. (${pendingTrains} left)</div>`;
                document.body.appendChild(modal);
            }
            // Update button list
            const btnsDiv = modal.querySelector('#trainAssignBtns');
            btnsDiv.innerHTML = '';
            Object.entries(lines).forEach(([color, line]) => {
                if (line.stations.length >= 2) {
                    const btn = document.createElement('button');
                    btn.textContent = colorToLabel(color);
                    btn.style.background = color;
                    btn.style.color = '#fff';
                    btn.style.fontWeight = 'bold';
                    btn.style.margin = '0 8px 8px 0';
                    btn.style.padding = '10px 18px';
                    btn.style.border = 'none';
                    btn.style.borderRadius = '8px';
                    btn.style.fontSize = '18px';
                    btn.style.cursor = 'pointer';
                    btn.onclick = () => {
                        // Disable all buttons immediately to prevent double click
                        btnsDiv.querySelectorAll('button').forEach(b => b.disabled = true);
                        addTrainToLine(color);
                        pendingTrains--;
                        if (pendingTrains > 0) {
                            setTimeout(showTrainAssignmentUI, 200); // slight delay to prevent double
                        } else {
                            hideTrainAssignmentUI();
                        }
                    };
                    btnsDiv.appendChild(btn);
                }
            });
            // Update count
            modal.querySelector('div[style*="color:#ccc"]').textContent = `Choose a line to add a train. (${pendingTrains} left)`;
        }
        function hideTrainAssignmentUI() {
            const modal = document.getElementById('trainAssignModal');
            if (modal) modal.remove();
        }
        function colorToLabel(color) {
            const map = {
                '#e74c3c': 'R', '#3498db': 'B', '#2ecc71': 'G', '#f39c12': 'Y', '#9b59b6': 'P', '#e67e22': 'O'
            };
            return map[color] || color;
        }
        // --- Add a train to a line at a random position ---
        function addTrainToLine(color) {
            const line = lines[color];
            if (!line || line.stations.length < 2) return;
            const { total } = computeLineSegments(line);
            const pos = Math.random() * total;
            line.trains.push({
                distance: pos,
                distanceFrac: total === 0 ? 0 : pos / total,
                direction: 1,
                passengers: [],
                color: color
            });
        }

        // --- Interchange assignment UI ---
        function showInterchangeAssignmentUI() {
            let modal = document.getElementById('interchangeAssignModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'interchangeAssignModal';
                modal.style.position = 'fixed';
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.background = 'rgba(0,0,0,0.95)';
                modal.style.padding = '30px 20px';
                modal.style.borderRadius = '12px';
                modal.style.zIndex = 9999;
                modal.style.textAlign = 'center';
                modal.style.boxShadow = '0 8px 32px #0008';
                modal.innerHTML = `<h3 style='margin-top:0'>Assign Interchange</h3><div style='margin-top:10px;font-size:13px;color:#ccc'>Click a station to upgrade to an interchange.</div>`;
                document.body.appendChild(modal);
            }
            // Highlight stations
            canvas.style.cursor = 'pointer';
            canvas.addEventListener('mousedown', handleInterchangeClick);
        }
        function hideInterchangeAssignmentUI() {
            const modal = document.getElementById('interchangeAssignModal');
            if (modal) modal.remove();
            canvas.style.cursor = '';
            canvas.removeEventListener('mousedown', handleInterchangeClick);
        }
        function handleInterchangeClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const station = stations.find(s => Math.hypot(s.x - x, s.y - y) < 30);
            if (station && !station.isInterchange && gameState.interchangesAvailable > 0) {
                station.isInterchange = true;
                gameState.interchangesAvailable--;
                hideInterchangeAssignmentUI();
                updateUI();
            }
        }
    </script>
</body>
</html>